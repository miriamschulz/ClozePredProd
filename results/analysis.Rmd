---
title: "Analysis"
author: "Miriam Schulz"
date: "2025-01-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Preliminaries

Libraries: 

```{r, message = FALSE}
# Preliminaries
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(gridExtra)
library(Rmisc)
library(lme4)
library(lmerTest)
```

Custom functions:

```{r}
preprocess_data <- function(df) {
  df$Region <- "other"
  # df <- filter(df, WordPosition %in% c("5", "6", "7", "8"))
  df <- df %>%
    mutate(Region = case_when(
      WordPosition == "5" ~ "pre-critical",
      WordPosition == "6" ~ "target",
      WordPosition == "7" ~ "spill1",
      WordPosition == "8" ~ "spill2"
    ))
  df$Region <- factor(df$Region, levels=c("pre-critical", "target",
                                          "spill1", "spill2"))
  df$RT <- as.numeric(df$RT)
  df$ExpCondition <- as.factor(df$ExpCondition)
  df <- df %>%
    # mutate(Subject = dense_rank(UniqueID))
    # mutate(Subject = as.numeric(factor(UniqueID)))
    mutate(Subject = match(UniqueID, unique(UniqueID)))
  df$Subject <- as.factor(df$Subject)
  df$Item <- as.factor(df$ExpItemNum)
  return(df)
}

print_RTs <- function(df) {
  df <- df %>% 
    dplyr::filter(Region != "pre-critical" & Region != "other")
  cat("Overall mean RT:")
  print(round(mean(df$RT), 2))
  cat("Mean RT by condition:")
  df %>%
    dplyr::group_by(ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print() 
  cat("Mean RT by condition & task:")
  df %>%
    dplyr::group_by(Task, ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print()
  cat("Mean RT by condition & task & region:")
  df %>%
    dplyr::group_by(Region, Task, ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print()
}

remove_outliers_thresholds <- function(df, min_rt = 80, max_rt = 2500) {
  nrow_orig <- nrow(df)
  df <- filter(df,
               RT > min_rt & RT < max_rt)
  nrow_new <- nrow(df)
  nrow_diff <- nrow_orig-nrow_new
  cat("Number of data points eliminated:", nrow_diff, "out of", nrow_orig)
  cat("  (", round(nrow_diff / nrow_orig * 100, 2), "%)", sep="")
  return(df)
}

remove_outliers_subj_sd <- function(df, sd_threshold=3) {
  nrow_orig <- nrow(df)
  df_subj_sd <- df %>% 
    summarySE(measurevar="RT",
              groupvars=c("UniqueID"),
              na.rm=T) %>% 
    select(UniqueID, RT, sd) %>% 
    dplyr::rename(MeanRT = RT)
  df <- merge(df, df_subj_sd, by="UniqueID")
  df <- df %>% 
    filter(RT < MeanRT+sd_threshold*sd & RT > MeanRT-sd_threshold*sd)
  df$sd <- NULL
  df$MeanRT <- NULL
  nrow_new <- nrow(df)
  nrow_diff <- nrow_orig-nrow_new
  cat("Number of data points eliminated:", nrow_diff, "out of", nrow_orig)
  cat("  (", round(nrow_diff / nrow_orig * 100, 2), "%)", sep="")
  return(df)
}
```


Read data:

```{r}
# Read preprocessed dfs
dat <- read.csv("results_preprocessed.csv", header=TRUE)

# dat_pilot3 <- read.csv("results_preprocessed_pilot3.csv", header=TRUE)
# colnames(dat)
# colnames(dat_pilot3)
# dat_pilot3$ClozeProb <- NA
# dat$ExpItemNum <- dat$ExpItemNumOriginal
# dat$ExpItemNumOriginal <- NULL
# dat_pilot3 <- dat_pilot3[, colnames(dat), drop = FALSE]
# dat <- rbind(dat, dat_pilot3)
```


Remove subjects to be excluded:

```{r}
dat <- dat %>%
  filter(!UniqueID %in% c("vuqqnd", "ee49u2", "vznkz3", "3jw4ew", "ps4dv4")) # non-natives
```


Extract critical regions & first check of RTs:

```{r}
dat <- preprocess_data(dat)
dat %>% 
  filter(ExpCondition %in% c("High", "Low")) %>% 
  print_RTs()
```


# Checks

## Data completeness check

```{r}
# Experimental conditions per subject
xtabs(~ UniqueID + ExpCondition, droplevels(filter(dat, Region == "target" &
                                            ExpCondition %in% c("High", "Low"))))

# Subset the data frame for more checks
completeness <- dat %>%
  select(UniqueID, Item, ExpCondition, Task, Block, RandomOrder, LatinList) %>%
  unique()

# All items
xtabs(~ Item, completeness)  # should show N participants everywhere

# Items by subject
xtabs(~ UniqueID + Item, completeness)  # should show 1 everywhere

# Task by subject
xtabs(~ UniqueID + Task, completeness)  # should show 80 everywhere

# Block by subject
xtabs(~ UniqueID + Block, completeness)  # should show 40 everywhere

# List by subject
xtabs(~ UniqueID + LatinList, completeness)  # must show 160 or 0 everywhere

# Random order
xtabs(~ RandomOrder + LatinList, completeness)  # should show 160 or 0; multiples of 160 mean some subjects ran the same order
```


## Comprehension question accuracy

```{r}
dat_acc <- dat %>%
  filter(!is.na(CorrectAnswer)) %>%
  select(CorrectAnswer, UniqueID, Item) %>% 
  unique()
  #filter(Region == "target")
dat_acc$TrialAccuracy <- ifelse(dat_acc$CorrectAnswer == "true", 1, 0)

# Completeness checks
table(xtabs(~ UniqueID, dat_acc)) # should equal N of comp trials with Q in the list & N subjects

# Acc for all trials
dat_acc_subj <- dat_acc %>%
  dplyr::group_by(UniqueID) %>%
  dplyr::summarize(Accuracy = mean(TrialAccuracy))
round(range(dat_acc_subj$Accuracy), 2)
round(mean(dat_acc_subj$Accuracy), 2)
```

As a sanity check: The calculated accuracy should equal the accuracy as calculated live during the experiment up to the last comprehension trial.

```{r}
dat %>%
  filter(Task == "Comprehension") %>% 
  filter(TrialCounterTask == max(TrialCounterTask)) %>% 
  select(UniqueID, RunningAccuracy) %>% 
  unique() %>% 
  mutate(RunningAccuracy = round(RunningAccuracy, 3)) %>%
  arrange(UniqueID)
```



## Production timeouts

Plot the number of production timeouts by participant:

```{r timeout-subjects-plot, fig.height=5, fig.width=15}
dat_Timeouts <- dat %>% 
  filter(Task == "Production") %>% 
  select(c("UniqueID", "ExpCondition", "ProductionTimeout",
           "ExpItemNum", "AnswerTime")) %>% 
  unique()
dat_Timeouts$ProductionTimeoutBinary <-
  ifelse(dat_Timeouts$ProductionTimeout == "TimedOut", 1, 0)

ggplot(data=dat_Timeouts,
       aes(UniqueID, ProductionTimeoutBinary, fill=UniqueID)) + 
  geom_bar(stat="identity",
           width=1,
           show.legend=FALSE) +
  xlab("Subject") +
  ylab("N Production Timeouts") +
  ggtitle("Production Timeouts by Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold')
  )
```


## Question answer time

Comprehension question Answer Time:

```{r}
dat_AnswerRTs <- dat %>%
  filter(QuestionText != "")
# hist(dat_AnswerRTs$AnswerTime, breaks = 25, col="steelblue")

ggplot(data=dat_AnswerRTs,
        aes(AnswerTime, fill=UniqueID)) + 
  geom_histogram(alpha = 0.5,
                 show.legend=TRUE) + 
  ggtitle("Histogram of question RT by subject") +
  labs(fill = "Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold'),
    strip.text = element_text(size = 18, face = "bold")
  ) 

# Filter out Answer Times shorter than 200ms and longer than 10s (arbitrary):
dat_AnswerRTs <- dat_AnswerRTs %>%
  filter(AnswerTime > 200 & AnswerTime < 10000)

range(dat_AnswerRTs$AnswerTime)
mean(dat_AnswerRTs$AnswerTime)
sd(dat_AnswerRTs$AnswerTime)
```


# Outlier elimination

To continue, keep only the precritical regions and regions of interest, and split the data into all and experimental items only:

```{r}
dat <- dat %>% 
  filter(Region != "other")
dat_all <- dat
dat <- dat %>%
  filter(dat$ExpItemType == "ExpItem")
```

Check for outliers:

```{r}
# hist(dat$RT, breaks = 25, col="steelblue")

rt_hist <- function(dat) {
  ggplot(data=dat,
        aes(RT, fill=UniqueID)) + 
  geom_histogram(alpha = 0.5,
                 show.legend=TRUE) + 
  ggtitle("RTs (all critical regions) by subject") +
  labs(fill = "Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold'),
    strip.text = element_text(size = 18, face = "bold")
  ) 
}
rt_hist(dat)
```

Remove trials with extreme RTs:

```{r}
# Items only:
dat <- remove_outliers_thresholds(dat)

# All trials:
dat_all <- remove_outliers_thresholds(dat_all)
```

Additional outlier elimination by SD by participant:

```{r}
dat <- remove_outliers_subj_sd(dat, sd_threshold=3)
dat_all <- remove_outliers_subj_sd(dat_all, sd_threshold=3)
```

Check region times after outlier elimination:

```{r}
print_RTs(dat)
```

```{r}
rt_hist(dat)
```



# Plots

## Bar plot (target region only!)

```{r rt-bar-plot}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(filter(dat, WordPosition == TargetPosition),
                      measurevar="RT",
                      groupvars=c("ExpCondition", "Task"),
                      na.rm=T)

# Determine maximal value for y-axis:
max_y <- max(c(dat_plot$RT + dat_plot$se))

# Plot:
ggplot(data=dat_plot,
       aes(ExpCondition, RT, fill=ExpCondition)) + 
  geom_bar(aes(fill=ExpCondition),
           stat="identity",
           width=1,
           show.legend=TRUE) +
  geom_errorbar(aes(ymin = RT-se, ymax = RT+se),
              width=0.1, linewidth=0.3) +
  # xlab("Condition") +
  ylab("Reading Time (ms)") +
  ggtitle("RT by Task (target)") +
  scale_fill_manual(values=c("navy", "steelblue1")) +
  ylim(0, max_y) +
  theme_minimal() + 
  theme(
      axis.title.x = element_text(size = 14, face = 'bold'),
      axis.title.y = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = 12, face = 'bold'),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 25, face = 'bold'),
      legend.position = "none",
      strip.text = element_text(size = 18, face = "bold")) + 
  facet_wrap(~Task)

ggsave("./plots/RTs_target_barplot.png", plot = last_plot(),
       width=6, height=4, dpi=320)
```


## Line plot

```{r rt-line-plot, fig.height=5, fig.width=8}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(dat,
                      measurevar="RT",
                      groupvars=c("Region", "ExpCondition", "Task"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = Region,
           y = RT,
           color = ExpCondition,
           group = ExpCondition)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                width = 0.2, 
                linewidth = 0.5) +
  facet_wrap(~Task) +
  labs(color = "Expectancy") +
  xlab("Region") +
  ylab("Reading Time (ms)") +
  ggtitle("Reading Times by Region") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold")
  ) +
  scale_color_manual(values = c("navy", "steelblue1"))

ggsave("./plots/RTs.png", plot = last_plot(),
       width=10, height=7, dpi=320)
```


## RTs by subject

```{r rt-subj-plot, fig.height=10, fig.width=15}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(dat,
                      measurevar="RT",
                      groupvars=c("Region", "ExpCondition",
                                  "Task", "UniqueID"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = Region,
           y = RT,
           color = ExpCondition,
           linetype = Task,
           group = interaction(ExpCondition, Task))) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                width = 0.2, 
                linewidth = 0.5) +
  facet_wrap(~UniqueID) +
  labs(color = "Expectancy") +
  xlab("Region") +
  ylab("Reading Time (ms)") +
  ggtitle("Reading Times by Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_color_manual(values = c("navy", "steelblue1"))

ggsave("./plots/RTs_subjects.png", plot = last_plot(),
       width=15, height=12, dpi=320)
```


## Line plot by item

```{r rt-item-plot, fig.height=10, fig.width=15}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(dat,
                      measurevar="RT",
                      groupvars=c("Region", "ExpCondition",
                                  "Task", "ExpItemNum"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = Region,
           y = RT,
           color = ExpCondition,
           linetype = Task,
           group = interaction(ExpCondition, Task))) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                width = 0.2, 
                linewidth = 0.5) +
  # facet_wrap(~ExpItemNum+Task) +
  facet_wrap(~ExpItemNum) +
  labs(color = "Expectancy") +
  xlab("Region") +
  ylab("Reading Time (ms)") +
  ggtitle("Reading Times by Item") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 14, face = "bold")
  ) +
  scale_color_manual(values = c("navy", "steelblue1"))

ggsave("./plots/RTs_items.png", plot = last_plot(),
       width=30, height=20, dpi=320)
```


## RT over time plot

Plot the RT over time (items and fillers; averaging across the 4 extracted regions).

```{r rt-time-plot, fig.height=7, fig.width=12}
dat_plot <- summarySE(dat_all,
                      measurevar="RT",
                      groupvars=c("Block", "TrialCounterGlobal",
                                  "UniqueID", "Task", "TaskOrder"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = TrialCounterGlobal,
           y = RT,
           color = UniqueID,
           linetype = Task,
           group = interaction(UniqueID, Block))) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 1.2) +
  # geom_line(linewidth = 1) +
  # geom_point(size = 2) +
  labs(color = "Subject", linetype = "Task") +
  xlab("Trial number") +
  ylab("Reading Time (ms)") +
  geom_vline(xintercept = 90, linetype = "solid", color = "black",
             linewidth = 0.8) +
  annotate("text", x = 87, y = 500, #y = max(dat_plot$RT-100),
           label = "Start second half",
           color = "black", angle = 90, hjust = 0.5) +
  ggtitle("Reading Times by Block") +
  facet_wrap(~TaskOrder) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold"),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 14, face = "bold")
  )

ggsave("./plots/RTs_over_time.png", plot = last_plot(),
       width=14, height=6, dpi=320)
```


## RTs by wordlength and frequency

```{r rt-wordlen-plot, eval=FALSE}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(filter(dat, Region == "target"),
                      measurevar="RT",
                      groupvars=c("TargetLength"),
                      na.rm=T)
dat_plot$TargetLength <- as.factor(dat_plot$TargetLength)

# Determine maximal value for y-axis:
max_y <- max(c(dat_plot$RT + dat_plot$se))

# Plot:
ggplot(data=dat_plot,
       aes(TargetLength, RT, fill=TargetLength)) +
  geom_bar(aes(fill=TargetLength),
           stat="identity",
           width=1,
           show.legend=TRUE) +
  geom_errorbar(aes(ymin = RT-se, ymax = RT+se),
              width=0.1, linewidth=0.3) +
  # xlab("Condition") +
  ylab("Reading Time (ms)") +
  ggtitle("Target RT by Word Length") +
  scale_fill_manual(values=c("navy", "steelblue1")) +
  ylim(0, max_y) +
  theme_minimal() + 
  theme(
      axis.title.x = element_text(size = 14, face = 'bold'),
      axis.title.y = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = 12, face = 'bold'),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 25, face = 'bold'),
      legend.position = "none",
      strip.text = element_text(size = 18, face = "bold"))

ggsave("./plots/RTs_target_barplot.png", plot = last_plot(),
       width=6, height=4, dpi=320)
```



# Models

```{r}
#dat$Item <- as.factor(dat$ExpItemNum)
#dat$Subject <- as.factor(dat$UniqueID)
dat$Expectancy <- droplevels(factor(dat$ExpCondition,
                                    levels = c("High", "Low")))
contrasts(dat$Expectancy) <- c(-0.5, 0.5)
dat$Task <- as.factor(dat$Task)
contrasts(dat$Task) <- c(-0.5, 0.5)
dat$logRT <- log(dat$RT)
dat$Cloze_c <- scale(dat$ClozeProb)
dat$Length_c <- scale(dat$TargetLength)
dat$Freq_c <- scale(dat$TargetFreq)

#TODO: residualize for word length + frequency instead?
#TODO: add precritical RT as predictor?
```


## Linear model of target region (sanity check)

A simple linear model with a binary predictor:

```{r linear-model}
summary(lm(logRT ~ Expectancy * Task + Length_c + Freq_c,
           data = filter(dat, Region == "target")))
```


## Target word

Lmer with cloze as predictor:

```{r lmer-target-cloze}
m_target <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   (1 + Cloze_c + Task | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "target"))
summary(m_target)
```

Lmer with binary expectancy as predictor:

```{r lmer-target-binary-expectancy}
m_target <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "target"))
summary(m_target)
```


## Spillover region 1

Lmer with cloze as predictor:

```{r lmer-spillover1-cloze}
m_spill1 <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   (1 + Cloze_c + Task | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "spill1"))
summary(m_spill1)
```

Lmer with binary expectancy as predictor:

```{r  lmer-spillover1-binary-expectancy}
# Spillover 1
m_spill1 <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "spill1"))
summary(m_spill1)
```


## Spillover region 2

Lmer with cloze as predictor:

```{r lmer-spillover2-cloze}
m_spill2 <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   (1 + Cloze_c + Task | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "spill2"))
summary(m_spill2)
```

Lmer with binary expectancy as predictor:

```{r  lmer-spillover2-binary-expectancy}
m_spill2 <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "spill2"))
summary(m_spill2)
```


## A pooled model for mean RT across all critical regions

```{r lmer-pooled-regions}
dat_meanregions <- dat %>% 
  filter(Region %in% c("target", "spill1", "spill2")) %>% 
  group_by(Subject, Item, Task, Cloze_c, Expectancy, Length_c, Freq_c) %>%
  dplyr::summarize(logRT = log(mean(RT)))

m_allregions <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   (1 + Cloze_c + Task | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = dat_meanregions)
summary(m_allregions)
```
