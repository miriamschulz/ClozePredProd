---
title: "Analysis"
author: "Miriam Schulz"
date: "2025-01-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Preliminaries

Libraries: 

```{r, message = FALSE}
# Preliminaries
rm(list = ls())
library(tidyverse)
library(ggplot2)
library(RColorBrewer)
library(gridExtra)
library(Rmisc)
library(lme4)
library(lmerTest)
```

Some script parameters that will determine which sections of the script will / will not be run:+

```{r}
# Remove bad participants (non-native, failed task etc)?
exclude_participants = TRUE

# Use only a subset of strong items with the minimal specified Cloze difference:
strong_item_subset = FALSE
cloze_difference <- 0.5

# Limit how many/which plots to generate:
exit_after_first_rt_plot = FALSE
plot_by_subject_rts = TRUE
plot_by_item_rts = TRUE
plot_inidividual_items = FALSE

# Quit before running the models:
run_models = TRUE
```


Custom functions:

```{r define-functions}
preprocess_data <- function(df) {
  
  # Annotate the region 
  df$Region <- "other"
  df <- df %>%
    mutate(Region = case_when(
      WordPosition == "5" ~ "pre-critical",
      WordPosition == "6" ~ "target",
      WordPosition == "7" ~ "spill1",
      WordPosition == "8" ~ "spill2"
    ))
  df$Region <- factor(df$Region, levels=c("pre-critical", "target",
                                          "spill1", "spill2"))
  
  # Transform variables
  df$RT <- as.numeric(df$RT)
  df$ExpCondition <- as.factor(df$ExpCondition)
  
  # Assign unique subject numbers from 1 to N
  df <- df %>%
    mutate(Subject = match(UniqueID, unique(UniqueID)))
  df$Subject <- as.factor(df$Subject)
  df$Item <- as.factor(df$ExpItemNum)
  
  # Add precritical RTs as new column (by Subject/Item)
  df_precrit <- df %>%
    dplyr::filter(Region == "pre-critical") %>%
    dplyr::select(Item, Subject, PreCriticalRT = RT)
  df <- df %>%
    left_join(df_precrit, by = c("Item", "Subject"))
  
  # Add a binary predictor to distinguish first vs. second half
  df$Half <- ifelse(df$Block %in% 1:2, "First Half", "Second Half")

  return(df)
}

print_RTs <- function(df) {
  df <- df %>% 
    dplyr::filter(Region != "pre-critical" & Region != "other")
  cat("Overall mean RT:")
  print(round(mean(df$RT), 2))
  cat("Mean RT by condition:")
  df %>%
    dplyr::group_by(ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print() 
  cat("Mean RT by condition & task:")
  df %>%
    dplyr::group_by(Task, ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print()
  cat("Mean RT by condition & task & region:")
  df %>%
    dplyr::group_by(Region, Task, ExpCondition) %>%
    dplyr::summarise(mean_RT = mean(RT, na.rm = TRUE)) %>%
    print()
}

remove_outliers_thresholds <- function(df, min_rt = 80, max_rt = 2500) {
  nrow_orig <- nrow(df)
  df <- filter(df,
               RT > min_rt & RT < max_rt)
  nrow_new <- nrow(df)
  nrow_diff <- nrow_orig-nrow_new
  cat("Number of data points eliminated:", nrow_diff, "out of", nrow_orig)
  cat("  (", round(nrow_diff / nrow_orig * 100, 2), "%)", sep="")
  return(df)
}

remove_outliers_subj_sd <- function(df, sd_threshold=3) {
  nrow_orig <- nrow(df)
  df_subj_sd <- df %>% 
    summarySE(measurevar="RT",
              groupvars=c("UniqueID"),
              na.rm=T) %>% 
    select(UniqueID, RT, sd) %>% 
    dplyr::rename(MeanRT = RT)
  df <- merge(df, df_subj_sd, by="UniqueID")
  df <- df %>% 
    filter(RT < MeanRT+sd_threshold*sd & RT > MeanRT-sd_threshold*sd)
  df$sd <- NULL
  df$MeanRT <- NULL
  nrow_new <- nrow(df)
  nrow_diff <- nrow_orig-nrow_new
  cat("Number of data points eliminated:", nrow_diff, "out of", nrow_orig)
  cat("  (", round(nrow_diff / nrow_orig * 100, 2), "%)", sep="")
  return(df)
}
```


Read data:

```{r read-data}
# Read preprocessed dfs
dat <- read.csv("results_preprocessed.csv", header=TRUE)
```


Remove subjects to be excluded:

```{r exclude-participants}
if (exclude_participants == TRUE) {
  dat <- dat %>%
    # nonnatives Prolific Exp 1
    filter(!UniqueID %in% c("vuqqnd", "ee49u2", "vznkz3",
                            "3jw4ew", "ps4dv4")) %>%  
    # non-natives / failed the task on Prolific exp 2:
    filter(!UniqueID %in% c("2jcruh", "e2zqww",
                            "0jxphp", "m7ugwz", "jocpf0", "pizxpx",
                            "hpttkp")) %>% 
    # MAYBE non-natives in Prolific exp 2:
    filter(!UniqueID %in% c("icak56", "8v42p8", "bdhmxy", "glbu6a",
                            "6wqbuo")) %>% 
    filter(!UniqueID %in% c("-u775t")) %>%  # technical problems: restarted 3x
    filter(!UniqueID %in% c("ev0tqj")) %>% # read contexts aloud in one prod block
    filter(!UniqueID %in% c("4ftnhn")) %>%  # no server data; born in Ghana
    filter(!UniqueID %in% c("teg94q"))  # comp accuracy ~50% and too many timeouts
}
```


Extract critical regions & first check of RTs:

```{r preprocess-data}
dat <- preprocess_data(dat)
dat %>% 
  filter(ExpCondition %in% c("High", "Low")) %>% 
  print_RTs()
```


# Checks

## Data completeness check

```{r completeness-checks}
# Experimental conditions per subject
xtabs(~ UniqueID + ExpCondition, droplevels(filter(dat, Region == "target" &
                                            ExpCondition %in% c("High", "Low"))))

# Subset the data frame for more checks
completeness <- dat %>%
  select(UniqueID, Item, ExpCondition, Task, Block, RandomOrder, LatinList) %>%
  unique()

# All items
range(xtabs(~ Item, completeness))  # should show N participants

# Items by subject
range(xtabs(~ UniqueID + Item, completeness))  # should range from 1 to 1

# Task by subject
xtabs(~ UniqueID + Task, completeness)  # should show 80 everywhere

# Block by subject
xtabs(~ UniqueID + Block, completeness)  # should show 40 everywhere

# Item by list
xtabs(~ Item + LatinList, completeness)  # N subjects per list everywhere

# List by subject
# xtabs(~ UniqueID + LatinList, completeness)  # must show 160 or 0 everywhere
completeness %>%
  select(LatinList, UniqueID) %>%
  arrange(LatinList) %>% 
  unique()

# Random order
xtabs(~ RandomOrder + LatinList, completeness)  # should show 160 or 0; multiples of 160 mean some subjects ran the same order
range(xtabs(~ RandomOrder + LatinList, completeness))

# Random Order by sorted by List
completeness %>% 
  select(LatinList, RandomOrder, UniqueID) %>% 
  unique() %>% 
  arrange(LatinList, RandomOrder)

# Random order sorted by subject
completeness %>%
  select(UniqueID, RandomOrder) %>%
  arrange(UniqueID) %>% 
  unique()

# Random order by subject+list (useful to get the latest RandomOrder used, i.e. counter state):
completeness %>% 
  select(UniqueID, RandomOrder, LatinList) %>% 
  unique()

# Subjects per list
n_trials <- 160
xtabs(~ LatinList, completeness) / n_trials
```


## Comprehension question accuracy

```{r question-accuracy}
dat_acc <- dat %>%
  filter(!is.na(CorrectAnswer)) %>%
  select(CorrectAnswer, UniqueID, LatinList, Item) %>% 
  unique()
  #filter(Region == "target")
dat_acc$TrialAccuracy <- ifelse(dat_acc$CorrectAnswer == "true", 1, 0)

# Completeness checks
table(xtabs(~ UniqueID, dat_acc)) # should equal N of comp trials with Q in the list & N subjects

# Acc for all trials
dat_acc_subj <- dat_acc %>%
  dplyr::group_by(UniqueID, LatinList) %>%
  dplyr::summarize(Accuracy = mean(TrialAccuracy))
# dat_acc_subj
round(range(dat_acc_subj$Accuracy), 2)
round(mean(dat_acc_subj$Accuracy), 2)
```

As a sanity check: The calculated accuracy should equal the accuracy as calculated live during the experiment up to the last comprehension trial.

```{r}
dat %>%
  filter(Task == "Comprehension") %>% 
  filter(TrialCounterTask == max(TrialCounterTask)) %>% 
  select(UniqueID, RunningAccuracy) %>% 
  unique() %>% 
  mutate(RunningAccuracy = round(RunningAccuracy, 3)) %>%
  arrange(UniqueID)
```

Plot the accuracy for fast visual inspection:

```{r accuracy-subjects-plot, fig.height=7, fig.width=10}
dat_acc_subj$UniqueID <- factor(dat_acc_subj$UniqueID, 
                                levels = dat_acc_subj$UniqueID[order(dat_acc_subj$Accuracy,
                                                                     dat_acc_subj$LatinList,
                                                                     decreasing = TRUE)])

ggplot(data=dat_acc_subj,
       aes(UniqueID, Accuracy, fill=as.factor(LatinList))) + 
  geom_bar(stat="identity",
           width=1,
           show.legend=TRUE,
           color = "black",
           alpha = 0.5) +
  geom_hline(yintercept = 0.7, linetype = "dashed", color = "black",
             linewidth = 0.8) +
  annotate("text",
           x = length(unique(dat_acc_subj$UniqueID)) / 2, y = 0.72,
           label = "70% accuracy",
           color = "black", size = 8, fontface = "bold",
           angle = 0) +
  labs(title = "Mean accuracy by subject", 
       subtitle = "All experimental trials, practice excluded", 
       x = "Subject", 
       y = "Mean accuracy",
       fill = "List") +
  scale_fill_manual(values=c("plum4", "steelblue4", "gray40", "darkred",
                             "plum2", "lightsteelblue", "gray70",
                             "lightcoral")) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold', angle = 90,
                               vjust = 0.5, hjust = 1),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
    plot.subtitle = element_text(size = 16, face = "italic", hjust = 0.5)
  )
```


## Production timeouts

Plot the number of production timeouts by participant:

```{r timeout-subjects-plot, fig.height=5, fig.width=15}
dat_Timeouts <- dat %>% 
  filter(Task == "Production") %>% 
  select(c("UniqueID", "ExpCondition", "ProductionTimeout",
           "ExpItemNum", "AnswerTime")) %>% 
  unique()
dat_Timeouts$ProductionTimeoutBinary <-
  ifelse(dat_Timeouts$ProductionTimeout == "TimedOut", 1, 0)

ggplot(data=dat_Timeouts,
       aes(UniqueID, ProductionTimeoutBinary, fill=UniqueID)) + 
  geom_bar(stat="identity",
           width=1,
           show.legend=FALSE) +
  xlab("Subject") +
  ylab("N Production Timeouts") +
  ggtitle("Production Timeouts by Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold', angle = 90,
                               vjust = 0.5, hjust = 1, margin = margin(t = 5)),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
    plot.subtitle = element_text(size = 18, face = "italic", hjust = 0.5)
  )
```


## Question answer time

Comprehension question Answer Time:

```{r question-answertime-plots}
dat_AnswerRTs <- dat %>%
  filter(QuestionText != "")

# Plot question answer times by subject
ggplot(data=dat_AnswerRTs,
        aes(AnswerTime, fill=UniqueID)) + 
  geom_histogram(alpha = 0.5,
                 show.legend=TRUE) + 
  labs(title = "Question RTs by Subject", 
       subtitle = "All conditions (including fillers)", 
       fill = "Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
    plot.subtitle = element_text(size = 16, face = "italic", hjust = 0.5),
    strip.text = element_text(size = 18, face = "bold")
  ) 

# Filter out Answer Times shorter than 200ms and longer than 10s (arbitrary):
dat_AnswerRTs <- dat_AnswerRTs %>%
  filter(AnswerTime > 200 & AnswerTime < 10000)

range(dat_AnswerRTs$AnswerTime)
mean(dat_AnswerRTs$AnswerTime)
sd(dat_AnswerRTs$AnswerTime)

# Plot question answer times by condition
ggplot(data=filter(dat_AnswerRTs, ExpCondition %in% c("High", "Low")),
        aes(AnswerTime, fill=ExpCondition)) + 
  geom_density(alpha = 0.7,
                 show.legend=TRUE) + 
  labs(title = "Question RTs by Condition", 
       subtitle = "Experimental conditions only; RTs filtered > 200ms & < 10s", 
       fill = "Subject") +
  scale_fill_manual(values=c("navy", "steelblue1")) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
    plot.subtitle = element_text(size = 16, face = "italic", hjust = 0.5),
    strip.text = element_text(size = 18, face = "bold")
  ) 
```


# Outlier elimination

To continue, keep only the precritical regions and regions of interest, and split the data into all and experimental items only:

```{r}
dat_all <- dat %>% 
  filter(!is.na(RT)) %>% 
  filter(Word != "")
dat <- dat %>% 
  filter(Region != "other")
dat <- dat %>%
  filter(dat$ExpItemType == "ExpItem")
```

Visually check for outliers:

```{r}
rt_hist <- function(dat, plot_subtitle) {
  ggplot(data=dat,
        aes(RT, fill=UniqueID)) + 
  geom_histogram(alpha = 0.5,
                 show.legend=TRUE) + 
  labs(title = "RTs by Subject",
       subtitle = plot_subtitle,
       fill = "Subject") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = 'bold'),
    axis.title.y = element_text(size = 14, face = 'bold'),
    axis.text.x = element_text(size = 12, face = 'bold'),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
    plot.subtitle = element_text(size = 16, face = "italic", hjust = 0.5),
    strip.text = element_text(size = 18, face = "bold")
  ) 
}
rt_hist(dat, plot_subtitle = "All critical regions, before outlier elimination")
```

Remove trials with extreme RTs:

```{r}
# Items only:
dat <- remove_outliers_thresholds(dat)

# All trials:
dat_all <- remove_outliers_thresholds(dat_all)
```

Additional outlier elimination by SD by participant:

```{r}
dat <- remove_outliers_subj_sd(dat, sd_threshold=3)
dat_all <- remove_outliers_subj_sd(dat_all, sd_threshold=3)
```

Check region times after outlier elimination:

```{r}
print_RTs(dat)
```

```{r}
rt_hist(dat, plot_subtitle = "All critical regions, after outlier elimination")
```

Export:

```{r}
write.csv(dat, "results_preprocessed_filtered.csv", row.names=FALSE)
```


## Subset for strong items (optional)

Set `use_subset = TRUE` here to look only at the "strongest" items in terms of Cloze probability in the entire following script.

```{r subset-strong-items}
if (strong_item_subset == TRUE) {
  
  dat_strong <- dat %>% 
    dplyr::group_by(Item, ExpCondition) %>%
    dplyr::summarise(mean_cloze = mean(ClozeProb), .groups = "drop") %>% # 
    pivot_wider(names_from = ExpCondition, values_from = mean_cloze) %>% # wide format
    mutate(difference = abs(High - Low)) %>% # Calculate the absolute difference
    filter(difference >= cloze_difference) %>% # Filter items with a difference >= 0.5
    select(Item)
  
  dat_strong <- dat %>% 
    filter(Item %in% dat_strong$Item) %>% 
    select(Item, ExpCondition, ClozeProb, TargetWord) %>% 
    unique() %>% 
    arrange(Item, ExpCondition)
  
  cat("FILTERING DATA SET FOR STRONG ITEMS ONLY\n")
  
  cat("Subsetting data frame for", length(unique(dat_strong$Item)),
      "unique items with a cloze probability difference of at least",
      cloze_difference, "between conditions.")
  
  dat <- dat %>% 
    filter(Item %in% dat_strong$Item)
}
```


# RT Plots

## Bar plot

```{r rt-bar-plot, fig.height=5, fig.width=12}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(filter(dat, !(Region %in% c("other"))),
                      measurevar="RT",
                      groupvars=c("ExpCondition", "Task", "Region"),
                      na.rm=T)

# Determine maximal value for y-axis:
max_y <- max(c(dat_plot$RT + dat_plot$se))
dat_plot$Region <- as.factor(dat_plot$Region)

# Plot:
ggplot(data=dat_plot,
       # aes(ExpCondition, RT, fill=ExpCondition)) +
       aes(ExpCondition, RT, fill = interaction(Task, ExpCondition))) + 
  geom_bar(#aes(fill=ExpCondition,
               # alpha = Task == "Production"
               # ),
           stat="identity",
           width=1,
           show.legend=TRUE) +
  geom_errorbar(aes(ymin = RT-se, ymax = RT+se),
              width=0.1, linewidth=0.3) +
  facet_wrap(~Region+Task, nrow = 1) +
  xlab("Condition") +
  ylab("Reading Time (ms)") +
  ggtitle("RTs by Task and Region") +
  # scale_fill_manual(name = "Condition",
  #                   values=c("navy", "steelblue1")) +
  scale_fill_manual(
    name = "Task and Condition", # Legend title
    values = c("Comprehension.High" = "navy", 
               "Comprehension.Low" = "lightsteelblue1",
               "Production.High" = "seagreen4",
               "Production.Low" = "#d5f5df"),
    labels = c("Comprehension: High", "Production: High",
               "Comprehension: Low", "Production: Low")
  ) +
  ylim(0, max_y) +
  theme_minimal() + 
  theme(
      axis.title.x = element_text(size = 14, face = 'bold'),
      axis.title.y = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = 12, face = 'bold'),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
      #legend.position = "none",
      strip.text = element_text(size = 18, face = "bold"),
      plot.background = element_rect(fill = "white", color = NA)
  )

ggsave("./plots/RTs_barplot.png", plot = last_plot(),
       width=18, height=6, dpi=320)
```


## Line plot

```{r rt-line-plot, fig.height=5, fig.width=8}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(dat,
                      measurevar="RT",
                      groupvars=c("Region", "ExpCondition", "Task"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = Region,
           y = RT,
           # color = interaction(Task, ExpCondition),
           color = ExpCondition,
           linetype = Task,
           group = ExpCondition)) +
  geom_line(linewidth = 1) +
  geom_point(size = 2, show.legend = FALSE) +
  geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                width = 0.2, 
                linewidth = 0.5) +
  facet_wrap(~Task) +
  xlab("Region") +
  ylab("Reading Time (ms)") +
  ggtitle("Reading Times by Task") +
  labs(color = "Expectancy") +
  scale_color_manual(values = c("navy", "steelblue1")) +
  # scale_color_manual(
  #   name = "Task and Condition", # Legend title
  #   values = c("Comprehension.High" = "navy",
  #              "Comprehension.Low" = "steelblue1",
  #              "Production.High" = "seagreen4",
  #              "Production.Low" = "#8de0a4"
  #              ),
  #   labels = c("HIGH - Comprehension", "LOW - Comprehension",
  #              "HIGH - Production", "LOW - Production"),
  #   breaks = c("Comprehension.High", "Comprehension.Low",
  #              "Production.High", "Production.Low"),
  #   guide = guide_legend(override.aes = list(linetype = c(1, 1, 2, 2)))
  # ) +
  # scale_linetype_manual(values = c("Comprehension" = "solid",
  #                                  "Production" = "dashed"),
  #                       guide = FALSE) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    legend.key.width = unit(1, "cm"),
    strip.text = element_text(size = 16, face = "bold"),
    plot.background = element_rect(fill = "white", color = NA)
  )

ggsave("./plots/RTs.png", plot = last_plot(),
       width=10, height=7, dpi=320)
```



```{r exit-before-plots}
if (exit_after_first_rt_plot == TRUE) {
  knitr::knit_exit()
}
```



## Plot by experimental half & task

```{r rt-line-plot-taskorder, fig.height=5, fig.width=8}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(dat,
                      measurevar="RT",
                      groupvars=c("Region", "ExpCondition",
                                  "Task", "Half"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = Region,
           y = RT,
           color = ExpCondition,
           linetype = Task,
           group = interaction(ExpCondition, Task))) +
  geom_line(linewidth = 1) +
  geom_point(size = 2) +
  geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                width = 0.2, 
                linewidth = 0.5) +
  facet_wrap(~Half) +
  labs(color = "Expectancy") +
  xlab("Region") +
  ylab("Reading Time (ms)") +
  ggtitle("Reading Times by Region and Task Order") +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 16, face = "bold"),
    plot.background = element_rect(fill = "white", color = NA)
  ) +
  scale_color_manual(values = c("navy", "steelblue1"))

ggsave("./plots/RTs_task_order.png", plot = last_plot(),
       width=10, height=7, dpi=320)
```


## Plot all subjects

```{r rt-subj-plot, fig.height=10, fig.width=15}
if (plot_by_subject_rts == TRUE) {
  
  # Generate a summary data frame including the SE:
  dat_plot <- summarySE(dat,
                        measurevar="RT",
                        groupvars=c("Region", "ExpCondition",
                                    "Task", "UniqueID"),
                        na.rm=T)
  
  p <- ggplot(data = dat_plot,
         aes(x = Region,
             y = RT,
             color = ExpCondition,
             linetype = Task,
             group = interaction(ExpCondition, Task))) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                  width = 0.2, 
                  linewidth = 0.5) +
    facet_wrap(~UniqueID) +
    labs(color = "Expectancy") +
    xlab("Region") +
    ylab("Reading Time (ms)") +
    ggtitle("Reading Times by Subject") +
    theme_minimal() +
    theme(
      axis.title.x = element_text(size = 14, face = "bold"),
      axis.title.y = element_text(size = 14, face = "bold"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      legend.title = element_text(size = 14),
      legend.text = element_text(size = 12),
      strip.text = element_text(size = 14, face = "bold"),
      plot.background = element_rect(fill = "white", color = NA)
    ) +
    scale_color_manual(values = c("navy", "steelblue1"))
  print(p)
  
  ggsave("./plots/RTs_subjects.png", plot = p,
         width=25, height=13, dpi=320)
}
```


## Plot all items

```{r rt-item-plot, fig.height=10, fig.width=15}
if (plot_by_item_rts == TRUE) {

  # Generate a summary data frame including the SE:
  dat_plot <- summarySE(dat,
                        measurevar="RT",
                        groupvars=c("Region", "ExpCondition",
                                    "Task", "ExpItemNum"),
                        na.rm=T)
  
  p <- ggplot(data = dat_plot,
         aes(x = Region,
             y = RT,
             color = ExpCondition,
             linetype = Task,
             group = interaction(ExpCondition, Task))) +
    geom_line(linewidth = 1) +
    geom_point(size = 2) +
    geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                  width = 0.2, 
                  linewidth = 0.5) +
    # facet_wrap(~ExpItemNum+Task) +
    facet_wrap(~ExpItemNum) +
    labs(color = "Expectancy") +
    xlab("Region") +
    ylab("Reading Time (ms)") +
    ggtitle("Reading Times by Item") +
    theme_minimal() +
    theme(
      axis.title.x = element_text(size = 14, face = "bold"),
      axis.title.y = element_text(size = 14, face = "bold"),
      axis.text.x = element_text(size = 12),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
      legend.title = element_text(size = 14),
      legend.text = element_text(size = 12),
      strip.text = element_text(size = 14, face = "bold"),
      plot.background = element_rect(fill = "white", color = NA)
    ) +
    scale_color_manual(values = c("navy", "steelblue1"))
  print(p)
  
  ggsave("./plots/RTs_items.png", plot = p,
         width=30, height=20, dpi=320)
}
```


## Individual item plots

Generate and save one plot for each item, with the words annotated above the x-axis:

```{r item-plots-individual}
if (plot_inidividual_items == TRUE) {
  dat_plot <- summarySE(dat_all,
                        measurevar="RT",
                        groupvars=c("Region", "ExpCondition",
                                    "Task", "Item",
                                    "WordPosition", "Word"),
                        na.rm=T)
  dat_plot$WordPosition <- as.numeric(dat_plot$WordPosition)
  summary(dat_plot$WordPosition)
  
  # for (i in c(1:80, 1001:1080)) {
  for (i in unique(as.numeric(as.character(dat_plot$Item)))) {
    dat_plot_item <- dat_plot %>% 
      filter(Item == i) %>% 
      group_by(WordPosition) %>%
      mutate(Word = if_else(
        WordPosition == 6,
        paste(unique(Word[WordPosition == 6]), collapse = "/"),
        Word)) %>%
      ungroup()
    item_no_char <- as.character(unique(dat_plot_item$Item))
    
    p <- ggplot(dat_plot_item,
                aes(x = WordPosition,
                y = RT,
                color = ExpCondition,
                linetype = Task,
                group = interaction(ExpCondition, Task))) +
      geom_line(linewidth = 1) +
      geom_point(size = 2) +
      geom_errorbar(aes(ymin = RT - se, ymax = RT + se), 
                    width = 0.2, 
                    linewidth = 0.5) +
      {if (as.numeric(item_no_char) < 1000)
           annotate("rect", xmin = 5.5, xmax = 8.5, ymin = -Inf, ymax = Inf, 
               fill = "gray", alpha = 0.3)} +
      labs(color = "Expectancy",
           title = paste0("Reading Times: Item ", item_no_char)) +
      scale_x_continuous(
        name = "Word Position",
        breaks = dat_plot_item$WordPosition,
        sec.axis = sec_axis(~ ., name = "Word",
                            breaks = dat_plot_item$WordPosition,
                            labels = dat_plot_item$Word)
      ) +
      ylab("Reading Time (ms)") +
      theme_minimal() +
      theme(
        axis.title.x = element_text(size = 14, face = "bold"),
        axis.title.y = element_text(size = 14, face = "bold"),
        axis.text.x = element_text(size = 12),
        axis.text.y = element_text(size = 12),
        plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        strip.text = element_text(size = 14, face = "bold"),
        plot.background = element_rect(fill = "white", color = NA)
      ) +
      scale_color_manual(values = c("navy", "steelblue1"))
    
    plot_title <- paste0("./plots/item_plots/item_", as.character(i), ".png")
    ggsave(plot_title, plot = p, width=12, height=5, dpi=320)
  }
}
```



## RT over time plot

Plot the RT over time (items and fillers; averaging across the 4 extracted regions).

```{r rt-time-plot, fig.height=7, fig.width=12}
dat_plot <- summarySE(dat_all,
                      measurevar="RT",
                      groupvars=c("Block", "TrialCounterGlobal",
                                  "UniqueID", "Task", "TaskOrder"),
                      na.rm=T)

ggplot(data = dat_plot,
       aes(x = TrialCounterGlobal,
           y = RT,
           color = UniqueID,
           linetype = Task,
           group = interaction(UniqueID, Block))) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 1.2) +
  # geom_line(linewidth = 1) +
  # geom_point(size = 2) +
  labs(color = "Subject", linetype = "Task") +
  xlab("Trial number") +
  ylab("Reading Time (ms)") +
  geom_vline(xintercept = 90, linetype = "solid", color = "black",
             linewidth = 0.8) +
  annotate("text", x = 87, y = 500, #y = max(dat_plot$RT-100),
           label = "Start second half",
           color = "black", angle = 90, hjust = 0.5) +
  ggtitle("Reading Times by Block") +
  facet_wrap(~TaskOrder) +
  theme_minimal() +
  theme(
    axis.title.x = element_text(size = 14, face = "bold"),
    axis.title.y = element_text(size = 14, face = "bold"),
    axis.text.x = element_text(size = 12),
    axis.text.y = element_text(size = 12),
    plot.title = element_text(size = 20, face = "bold", hjust = 0.5),
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text = element_text(size = 14, face = "bold"),
    plot.background = element_rect(fill = "white", color = NA)
  )

ggsave("./plots/RTs_over_time.png", plot = last_plot(),
       width=14, height=6, dpi=320)
```


## RTs by wordlength

```{r rt-targetlength-plot}
# Generate a summary data frame including the SE:
dat_plot <- summarySE(filter(dat, !(Region %in% c("other"))),
                      measurevar="RT",
                      groupvars=c("TargetLength", "Region"),
                      na.rm=T)
# dat_plot$TargetLength <- as.factor(dat_plot$TargetLength)

# Determine maximal value for y-axis:
max_y <- max(c(dat_plot$RT + dat_plot$se))

# Plot:
ggplot(data=dat_plot,
       aes(TargetLength, RT)) +
  # geom_bar(aes(fill=TargetLength),
  #          stat="identity",
  #          width=1,
  #          show.legend=TRUE) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 1.2, color = "steelblue") +
  geom_point(color = "steelblue", size = 3) +
  geom_errorbar(aes(ymin = RT-se, ymax = RT+se),
              width=0.1, linewidth=0.3) +
  xlab("Target Word Length in N characters") +
  ylab("Reading Time (ms)") +
  ggtitle("RT by Target Word Length") +
  ylim(0, max_y) +
  facet_wrap(~ Region) +
  theme_minimal() + 
  theme(
      axis.title.x = element_text(size = 14, face = 'bold'),
      axis.title.y = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = 12, face = 'bold'),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
      legend.position = "none",
      strip.text = element_text(size = 18, face = "bold")
  )
```

## RTs by target word frequency

```{r rt-targetfreq-plot, fig.height=7, fig.width=12}
# Generate a summary data frame including the SE:
dat_plot <- dat %>% 
  filter(!(Region %in% c("other"))) %>% 
  mutate(TargetFreq = round(TargetFreq, 1))

dat_plot <- summarySE(dat_plot,
                      measurevar="RT",
                      groupvars=c("TargetFreq", "Region"),
                      na.rm=T)
# dat_plot$TargetFreq <- as.factor(dat_plot$TargetFreq)

# Determine maximal value for y-axis:
max_y <- max(c(dat_plot$RT + dat_plot$se))

# Plot:
ggplot(data=dat_plot,
       aes(TargetFreq, RT)) +
  # geom_bar(aes(fill=TargetFreq),
  #          stat="identity",
  #          width=1,
  #          position = position_dodge(0.8),
  #          show.legend=TRUE) +
  geom_smooth(method = "lm", se = TRUE, linewidth = 1.2, color = "steelblue") +
  geom_point(color = "steelblue", size = 3) +
  geom_errorbar(aes(ymin = RT-se, ymax = RT+se),
              width=0.2, linewidth=0.3) +
              # position = position_dodge(0.8)) +
  xlab("Target Word Frequency (log10 SUBTLEX, rounded to 1 decimal)") +
  ylab("Reading Time (ms)") +
  ggtitle("RT by Target Word Frequency") +
  ylim(0, max_y) +
  facet_wrap(~ Region) +
  theme_minimal() + 
  theme(
      axis.title.x = element_text(size = 14, face = 'bold'),
      axis.title.y = element_text(size = 14, face = 'bold'),
      axis.text.x = element_text(size = 10, angle = 90),
      axis.text.y = element_text(size = 12),
      plot.title = element_text(size = 25, face = 'bold', hjust = 0.5),
      legend.position = "none",
      strip.text = element_text(size = 18, face = "bold")
  )
```


```{r exit-before-models}
if (run_models == FALSE) {
  knitr::knit_exit()
}
```



# Models


```{r}
dat$Expectancy <- droplevels(factor(dat$ExpCondition,
                                    levels = c("High", "Low")))
contrasts(dat$Expectancy) <- c(-0.5, 0.5)
dat$Task <- as.factor(dat$Task)
contrasts(dat$Task) <- c(-0.5, 0.5)
dat$logRT <- log(dat$RT)
dat$logPreCritRT <- log(dat$PreCriticalRT)
dat$Cloze_c <- scale(dat$ClozeProb)
dat$Length_c <- scale(dat$TargetLength)
dat$Freq_c <- scale(dat$TargetFreq)

dat$TrialCounterTask_c <- scale(dat$TrialCounterTask)
dat$TrialCounterGlobal_c <- scale(dat$TrialCounterGlobal)

dat$Half <- factor(dat$Half, levels = c("First Half", "Second Half"))
contrasts(dat$Half) <- c(-0.5, 0.5)

dat$TaskOrder <- factor(dat$TaskOrder, levels = c("comp_prod", "prod_comp"))
contrasts(dat$TaskOrder) <- c(-0.5, 0.5)
dat$BlocksReversed <- factor(dat$BlocksReversed, levels = c("False", "True"))
contrasts(dat$BlocksReversed) <- c(-0.5, 0.5)

#TODO: residualize for word length + frequency instead?
#TODO: add precritical RT as predictor?
```


## Linear model of target region (sanity check)

A simple linear model with a binary predictor:

```{r linear-model}
summary(lm(logRT ~ Expectancy * Task + Length_c + Freq_c,
           data = filter(dat, Region == "target")))
```


## Target word

Lmer with cloze as predictor:

```{r lmer-target-cloze, eval = FALSE}
m_target_cloze <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   TrialCounterTask_c + logPreCritRT +
                   (1 + Cloze_c + Task + TrialCounterTask_c | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "target"))
summary(m_target_cloze)
```

Lmer with binary expectancy as predictor:

```{r lmer-target-binary-expectancy, eval = FALSE}
m_target <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "target"))
summary(m_target)
```


## Spillover region 1

Lmer with cloze as predictor:

```{r lmer-spillover1-cloze, eval = FALSE}
m_spill1_cloze <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   TrialCounterTask_c +
                   logPreCritRT +
                   (1 + Cloze_c + Task + TrialCounterTask_c | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "spill1"))
summary(m_spill1_cloze)
```

```{r lmer-spillover1-cloze-half, eval = FALSE}
# A main effect of half
lmer(logRT ~ Cloze_c + Task + Length_c + Freq_c + 
       Half +
       (1 | Subject) +
       (1 | Item),
     data = filter(dat, Region == "spill1")) %>% summary()

# But: this goes away when adding the random slope for Half, suggesting
# that this effect hinges on some participants:
lmer(logRT ~ Cloze_c + Task + Length_c + Freq_c + 
       Half +
       (1 + Half | Subject) +
       (1 | Item),
     data = filter(dat, Region == "spill1")) %>% summary()

# Reversed block order should have no effect
lmer(logRT ~ Cloze_c + Task + Length_c + Freq_c + 
       BlocksReversed +
       (1 | Subject) +
       (1 | Item),
     data = filter(dat, Region == "spill1")) %>% summary()
```


Lmer with binary expectancy as predictor:

```{r  lmer-spillover1-binary-expectancy, eval = FALSE}
# Spillover 1
m_spill1 <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "spill1"))
summary(m_spill1)
```


## Spillover region 2

Lmer with cloze as predictor:

```{r lmer-spillover2-cloze, eval = FALSE}
m_spill2_cloze <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                 TrialCounterTask_c + logPreCritRT +
                   (1 + Cloze_c + Task + TrialCounterTask_c | Subject) +
                   (1 + Cloze_c + Task | Item),
                 data = filter(dat, Region == "spill2"))
summary(m_spill2_cloze)
```

Lmer with binary expectancy as predictor:

```{r  lmer-spillover2-binary-expectancy, eval = FALSE}
m_spill2 <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
                   (1 + Expectancy + Task | Subject) +
                   (1 + Expectancy + Task | Item),
                 data = filter(dat, Region == "spill2"))
summary(m_spill2)
```


## Plot model coefficients

```{r coef-plot}
get_coefficients <- function(m) {
  coef_data <- coef(summary(m)) %>%
  as.data.frame() %>%
  rownames_to_column(var = "term") %>%
  filter(term != "(Intercept)") %>% 
  dplyr::rename(
    estimate = Estimate,
    std.error = `Std. Error`,
    statistic = `t value`,
    p.value = `Pr(>|t|)`
  )
  return(coef_data)
}

dat_coef <- NULL
# for (region in c("pre-critical", "target", "spill1", "spill2")) {
for (region in c("target", "spill1", "spill2")) {
  dat_region <- dat %>% filter(Region == region)
  
  # m <- lmer(logRT ~ Expectancy * Task + Length_c + Freq_c +
  #             (1 | Subject) +
  #             (1 | Item),
  #           data = dat_region)
  
  m <- lmer(logRT ~ Cloze_c * Task + Length_c + Freq_c +
                   TrialCounterTask_c +
                   logPreCritRT +
                   (1 + Cloze_c + Task | Subject) +
                   (1 | Item),
            data = dat_region)
  
  print("---------------------------------------------------------------------")
  print("MODEL SUMMARY FOR REGION:")
  print(region)
  print(summary(m))
            
  coef_region <- get_coefficients(m)
  coef_region$Region <- region
  
  if (!exists("dat_coef")) {
    dat_coef <- coef_region
    } else {
    dat_coef <- rbind(dat_coef, coef_region)
  }
}

dat_coef$Region <- factor(dat_coef$Region, levels =
                            c("pre-critical","target",
                              "spill1", "spill2"))

ggplot(filter(dat_coef, Region != "pre-critical"), aes(x = Region, y = estimate,
                     color = term)) +
  geom_errorbar(aes(ymin = estimate - std.error,
                    ymax = estimate + std.error),
                width=0.1, linewidth=0.1, color = "black") +
  geom_point(aes(shape = p.value < 0.05), size = 3) +
  geom_hline(yintercept = 0, color = "black") +
  scale_shape_manual(values = c(13, 19)) +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Model Coefficients",
       x = "Region",
       y = "Coefficient Estimate",
       color = "Predictor") +
  theme_minimal()
```

