---
title: "Format stimuli for PCIbex"
author: "Miriam Schulz"
date: "2024-11-21"
output:
  html_document:
    number_sections: true
    toc: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# About

This script reads in a `csv` stimuli and fillers file for the Cloze Prediction & Production experiment and transforms the items to a `csv` file that can be used as a data file on PCIbex.


# Experimental items

## Select chosen items

In a first step, the data is read in and the chosen items (indicated by a $1$ in the column `picked`) are subsetted:

```{r, message=FALSE}
library("tidyverse")
```

```{r}
rm(list = ls())  # optional, clear workspace
dat <- read.csv("stim_exp.csv", header=TRUE)
#dat <- filter(dat, candidates=="1")
#xtabs(~ candidates + item_id, dat)

# Print items that do not occur exactly twice
subset(as.data.frame(xtabs(~ item_id + candidates, dat)), Freq != 2)

# Read in fillers
fillers <- read.csv("fillers.csv", header=TRUE)
```


## Transform to PCIbex formatting

We want to generate two files from this: a `comprehension.csv` and a `production.csv` file.

First, select the necessary columns.

### Preprocess items

```{r}
dat <- rename(dat,  ItemNum = item_id)
dat <- rename(dat,  TargetWord = target)
dat <- rename(dat,  TargetLength = length)
# dat <- rename(dat,  Group = Latin_list)
dat$Group <- dat$Latin_list
dat$Type <- "ExpItem"
dat <- rename(dat,  ExpCondition = cond)
dat$TargetPosition <- 6

dat$Sentence <- paste(dat$W1, dat$W2, 
                              dat$W3, dat$W4,
                              dat$LastWord, dat$TargetWord, 
                              dat$Spill1, dat$Spill2,
                              dat$Continuation, #dat$End,
                              sep = " ")

dat <- rename(dat,  ContextNoun = W3)

dat <- select(
  dat,
  c(
    "Group", "Latin_list", "Block",
    "ItemNum",
    "Type", "ExpCondition",
    "Sentence", "End",
    "TargetPosition", "TargetWord", "Lg10WF", "TargetLength",
    "ContextNoun",
    "HasQuestion", "Question", "Answer"
    #"overlap_t", "overlap_c"
  )
)
```

Remove any trailing whitespaces in the fillers and items:

```{r}
dat <- dat %>% 
  mutate(Sentence = gsub("\\s{2,}", " ", Sentence))

dat$TargetWord <- trimws(dat$TargetWord, which = "both")

fillers <- fillers %>% 
  mutate(Sentence = gsub("\\s{2,}", " ", Sentence))

fillers$Target <- trimws(fillers$Target, which = "both")
```


### Preprocess fillers

```{r}
fillers <- rename(fillers,  ItemNum = Filler_id)
fillers <- rename(fillers, ExpCondition = FillerType)
fillers$Type <- "ExpFiller"

# Split into practice vs. fillers
fillers$ItemNum <- as.numeric(fillers$ItemNum)
prac <- filter(fillers, ItemNum > 500)
fillers <- filter(fillers, ItemNum < 500)

# Make the filler numbers higher: start at 1001
fillers$ItemNum <- fillers$ItemNum + 1000

# Append to the filler condition if something is unexpected
fillers$Unexpected <- ifelse(fillers$Unexpected == "yes", "Unexp", "Exp")
fillers$ExpCondition <- paste(fillers$ExpCondition, fillers$Unexpected, sep="_")

# Add Latin list
fillers <- rbind(fillers, fillers)
fillers$Group <- rep(1:2, each = nrow(fillers)/2)
fillers$Latin_list <- fillers$Group

fillers <- rename(fillers, End = Target)
fillers$TargetPosition <- NA
fillers$TargetWord <- NA
fillers$Lg10WF <- NA
fillers$TargetLength <- NA
fillers$ContextNoun <- NA
# fillers$overlap_t <- NA
# fillers$overlap_c <- NA

fillers <- select(
  fillers,
  c(
    "Group", "Latin_list", "Block",
    "ItemNum",
    "Type", "ExpCondition",
    "Sentence", "End",
    "TargetPosition", "TargetWord", "Lg10WF", "TargetLength",
    "ContextNoun",
    "HasQuestion", "Question", "Answer"
    #"overlap_t", "overlap_c"
  )
)
```

Merge fillers and items

```{r}
summary(colnames(dat) == colnames(fillers))
all <- rbind(dat, fillers)
```

Add the AnswerKey Column:

```{r}
all$AnswerKey <- ifelse(all$Answer == "FALSE", "F",
                        ifelse(all$Answer == "TRUE", "J", ""))
```

# Check results and export

Check for completeness and balancedness:

```{r}
xtabs(~ ExpCondition, all)
```

```{r}
prop.table(xtabs(~ HasQuestion, all))
xtabs(~ Answer, all)
xtabs(~ AnswerKey, all)
```

Check for noun overlap:

```{r}
# Targets
dupl_targets <- sort(table(dat[["TargetWord"]])[table(dat[["TargetWord"]]) > 1],
                     decreasing=TRUE)
dupl_targets
length(dupl_targets)

# Context nouns
dupl_contexts <- sort(table(dat[["ContextNoun"]])[table(dat[["ContextNoun"]]) > 2],
                      decreasing=TRUE) / 2
dupl_contexts
length(dupl_contexts)

# Target & context
context_nouns <- names(table(dat[["ContextNoun"]]) / 2)
target_nouns <- names(table(dat[["TargetWord"]]))
intersect(context_nouns, target_nouns)
```

Generate the other lists with a for loop and write to file:

```{r}
# write.csv(all, "stim_preprocessed.csv", row.names=FALSE)
format_for_comp <- function(data) {
  data$Sentence <- paste(data$Sentence, data$End, sep = " ")
  data <- data %>% 
    mutate(Sentence = gsub("\\s{2,}", " ", Sentence))
  return(data)
}

generate_filename <- function(l, b, m) {
  return(paste("pcibex_lists/list", l, "_block", b, "_", m, ".csv", sep=""))
}

for (m in 1:2) {
  for (l in 1:2) {
    li <- filter(all, Group == l)
    for (b in 1:4) {
      block <- filter(li, Block == b)
      if (m == 1) {
        # blocks 1+2 will be comp, blocks 3+4 will be prod
        if (b %in% 1:2) {
          block <- format_for_comp(block)
          # filename <- paste("list", l, "_block", b, "_comp", ".csv", sep="")
          filename <- generate_filename(l, b, "comp")
        } else {
           # filename <- paste("list", l, "_block", b, "_prod", ".csv", sep="")         
           filename <- generate_filename(l, b, "prod")
        }
      } else {
        # blocks 1+2 will be prod, blocks 3+4 will be comp
        if (b %in% 1:2) {
          # filename <- paste("list", l+2, "_block", b, "_prod", ".csv", sep="") 
          filename <- generate_filename(l+2, b, "prod")
        } else {
          block <- format_for_comp(block)
          # filename <- paste("list", l+2, "_block", b, "_comp", ".csv", sep="")
          filename <- generate_filename(l+2, b, "comp")
        }
      }
      #filename <- paste("list", l, "_block", b, ".csv", sep="")
      write.csv(block, filename, row.names=FALSE)
      print(paste("Wrote to file:", filename, sep=" "))
    }
  }
}
```



# Practice items

```{r}
prac$Group <- 1  #TODO
prac$Block <- "prac"
prac$Type <- "ExpPractice"
prac$TargetPosition <- NA
prac$TargetWord <- NA
prac$Lg10WF <- NA
prac <- rename(prac,  End = Target)

prac$Sentence <- ifelse(prac$ExpCondition == "prac_comprehension",
                        paste(prac$Sentence, prac$End, sep = " "),
                        prac$Sentence)
    
prac <- select(
  prac,
  c("Group", "Block", "ItemNum",
    "Type", "ExpCondition",
    "Sentence", "End",
    "TargetPosition", "TargetWord", "Lg10WF",
    "HasQuestion", "Question", "Answer"
  )
)

# Add columns required by PCIbex to subset the comp/prod practice items:
prac$label <- 0
prac$group <- 0
```

```{r}
write.csv(prac, "practice.csv", row.names=FALSE)
```
